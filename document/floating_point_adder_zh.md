# 五级流水线浮点数加法器

## 处理特殊值(第一级)

模块：传入最初的两个操作数，传出特殊值状态。
流水寄存器：寄存两个操作数；特殊值状态（模块的输出）

逻辑：

* 不合法值 （NAN）
    * 指数值全 1，尾数值非全 0
    * 如果两个操作数有一个不合法值，即传出不合法状态
    * 如果两个操作数为一个正无穷和一个负无穷，即传出不合法状态
* 无穷值（INF）
    * 指数值全 1，尾数值全 0
    * 如果两个操作数有一个为无穷值，或都为正/负无穷，即传出无穷值状态
* 零值（ZERO）
    * 如果两个操作数绝对值为 0 ，即传出 0 值状态
* 一般值（NORMAL）
    * 如果上述条件都不满足，传出标准状态

## 对齐指数位（第二级）

模块：传入两个操作数，传出绝对值更大操作数的指数、绝对值更大操作数的（包含保护位）移位后的尾数和符号、绝对值更小操作数的（包含保护位）移位后的尾数和符号
流水寄存器：特殊值状态; 模块的输出

逻辑：

* 比较两个操作数的绝对值（比较指数大小和尾数大小，如果指数一样大就看尾数）
    * 输出更大绝对值数的指数，和有更大绝对值操作数的符号
    * 计算两个指数的差
    * 如果两个指数的差值大于尾数和保护位长度的和了，则限制为尾数和保护位长度之和
* 输出符号
    * 输出具有更大绝对值的操作数的符号和具有更小绝对值操作数的符号
* 尾数处理
    * 提取两个操作数的尾数
    * 对于两个尾数，如果其指数不为0，则在MSB添加前导 1，否则在MSB添加前导0
    * 在两个尾数的MLB添加保护位长度个0
    * 输出指数大的尾数
    * 把指数小的尾数右移差值位，输出

## 尾数位计算（第三级）

模块：输入具有原始更大指数的操作数的符号和尾数（具有前导1和保护位），具有原始更小指数的操作数的尾数；输出计算后的尾数（具有进位位，前导1和保护位），实际运算类型，和计算后的结果符号

流水寄存器：特殊值状态，第二级输出的指数；模块的输出

逻辑：

* 给两个尾数添加前导 0，应对可能的进位
* 尾数计算
    * 判断两个操作数符号是否相同
    * 如果相同，计算两个尾数之和
    * 如果不同，计算大尾数减小尾数
* 结果符号
    * 如果运算结果为减法时得到 0，符号为正
    * 否则符号为大尾数的符号
* 运算类型
    * 输出实际计算类型是加法还是减法

## 规格化 （第四级）

模块：输入指数，第三级计算后的尾数（具有进位位，前导1和保护位），实际运算类型；输出规格化的结果尾数(具有前导1和保护位)，规格化的指数

流水寄存器：特殊值状态；符号位；模块输出

逻辑：

* 如果尾数位的计算类型为加法，且产生了进位（体现在尾数的进位位为1），则指数位加一，尾数位取从MSB到MLB+1位
* 如果尾数位的计算类型为减法，且尾数结果的前导1位被减为0，则计算结果从前导1位到最低位有多少个前导0
    * 如果前导0的数量比结果指数还大，左移位数位结果指数，否则为前导0数量
    * 将指数位减去左移位数
    * 将尾数位左移相应的位数

## 舍入 （第五级）

模块：输入特殊状态，符号位，规格化指数，规格化尾数（具备前导1和保护位），输出最终结果

逻辑：

* 如果状态为特殊状态，直接将结果赋值为特殊值
* 对保护位进行舍入，策略为，如果保护位的值小于一半则不进位，如果大于一半则进位，如果等于一半则在尾数为奇数时进位；进位时对尾数加一
* 如果有进位，则对指数位加一
* 如果指数位已经溢出，则赋值为无穷，符号保持输入符号位
* 如果没有溢出的情况下出现进位，则取尾数右移的结果，如果没有进位，取尾数段结果

![alt text](/pics/fp_adder.png)